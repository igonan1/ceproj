//
//
//
//
//
//16...
//8,9,10,11,12,13,14,15,
//0,1,2,3,4,5,6,7, (1rank)
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#define convert(x,y) x+8*y//x,y=0~7
struct bitboard{
    uint64_t pawn;
    uint64_t knight;
    uint64_t bishop;
    uint64_t rook;
    uint64_t queen;
    uint64_t king;
};
typedef struct bitboard board;
board white={(uint64_t)0b11111111<<8,(uint64_t)0b01000010,(uint64_t)0b00100100,(uint64_t)0b10000001,(uint64_t)0b00010000,(uint64_t)0b00001000};
board black={(uint64_t)0b11111111<<48,(uint64_t)0b01000010<<56,(uint64_t)0b00100100<<56,(uint64_t)0b10000001<<56,(uint64_t)0b00010000<<56,(uint64_t)0b00001000<<56};
uint8_t popcnt(uint64_t n){
    int a=n;
    int depth=0;
    for(int i=0;a!=0;i++){
        a=a&(a-1);
        depth++;
    }
    return depth;
}
uint8_t location(uint64_t selected_board,uint8_t n){//location of nth bit
    int count=0;
    uint8_t table[64]={0};
    if((n>popcnt(selected_board))|(popcnt(selected_board)==0)){
        return 0;//invalid
    }
    for(int i=0;i<64;i++){
        if((selected_board>>i)&1){
            table[count]=i;
            count++;
        }
    }
    return table[n];
}
bool check_square(board friendly,board enemy,uint8_t pos,int color){//0=friendly 1=enemy 2=all
    if(color==0){
        if(((friendly.pawn>>pos)&1)|((friendly.knight>>pos)&1)|((friendly.bishop>>pos)&1)|((friendly.rook>>pos)&1)|((friendly.queen>>pos)&1)|((friendly.king>>pos)&1)){return 1;}
    }
    if(color==1){
        if(((enemy.pawn>>pos)&1)|((enemy.knight>>pos)&1)|((enemy.bishop>>pos)&1)|((enemy.rook>>pos)&1)|((enemy.queen>>pos)&1)|((enemy.king>>pos)&1)){return 1;}
    }
    if(color==2){
        if(((friendly.pawn>>pos)&1)|((friendly.knight>>pos)&1)|((friendly.bishop>>pos)&1)|((friendly.rook>>pos)&1)|((friendly.queen>>pos)&1)|((friendly.king>>pos)&1)){
            if(((enemy.pawn>>pos)&1)|((enemy.knight>>pos)&1)|((enemy.bishop>>pos)&1)|((enemy.rook>>pos)&1)|((enemy.queen>>pos)&1)|((enemy.king>>pos)&1)){return 1;}
        }
    }
}
void legal_move_generator(board friendly,board enemy,int *table){//friendly!=white
    table=(int*)malloc(2000*sizeof(int));//form of (original coordinate, next coordinate), 0~5th bit to board, 6th bit to promote to bishop, 7th bit to knight, 8th bit to rook, 9th bit to queen
    int length;
    int pos;
    int x;
    int y;
    for(int i=0;i<popcnt(friendly.pawn);i++){//pawn
        pos=location(friendly.pawn,i);
        x=pos%8;
        y=pos/8;
        if(!check_square(friendly,enemy,pos+8,2)){
            if(y==7){
                for(int j=6;j<10;j++){//promotion
                    table[length]=pos;
                    table[length+1]=(pos+8)&(1<<j);
                    length+=2;
                }
            }
            else{//move 1sq forward
                table[length]=pos;
                table[length+1]=pos+8;
                length+=2;
            }
            if(y==1){//move 2sq forward when y==1
                if(!check_square(friendly,enemy,pos+16,2)){
                    table[length]=pos;
                    table[length+1]=pos+16;
                    length+=2;
                }
            }
        }
    }
    for(int i=0;i<popcnt(friendly.knight);i++){
        pos=location(friendly.pawn,i);
        x=pos%8;
        y=pos/8;
    }
}
int main(){
    return 0;
}
