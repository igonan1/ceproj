//
//
//
//
//
//16...
//8,9,10,11,12,13,14,15,
//0,1,2,3,4,5,6,7, (1rank)
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#define convert(x,y) x+8*y//x,y=0~7
struct bitboard{
    uint64_t pawn;
    uint64_t knight;
    uint64_t bishop;
    uint64_t rook;
    uint64_t queen;
    uint64_t king;
};
typedef struct bitboard board;
board white={(uint64_t)0b11111111<<8,(uint64_t)0b01000010,(uint64_t)0b00100100,(uint64_t)0b10000001,(uint64_t)0b00010000,(uint64_t)0b00001000};
board black={(uint64_t)0b11111111<<48,(uint64_t)0b01000010<<56,(uint64_t)0b00100100<<56,(uint64_t)0b10000001<<56,(uint64_t)0b00010000<<56,(uint64_t)0b00001000<<56};
uint8_t popcnt(uint64_t n){
    int a=n;
    int depth=0;
    for(int i=0;a!=0;i++){
        a=a&(a-1);
        depth++;
    }
    return depth;
}
uint8_t location(uint64_t selected_board,uint8_t n){//location of nth bit
    int count=0;
    uint8_t table[64]={0};
    if((n>popcnt(selected_board))|(popcnt(selected_board)==0)){
        return 0;//invalid
    }
    for(int i=0;i<64;i++){
        if((selected_board>>i)&1){
            table[count]=i;
            count++;
        }
    }
    return table[n];
}
bool check_square(board white,board black,uint8_t pos,bool color){//0=white 1=black
    if(color){
        if(((black.pawn>>pos)&1)|((black.knight>>pos)&1)|((black.bishop>>pos)&1)|((black.rook>>pos)&1)|((black.queen>>pos)&1)|((black.king>>pos)&1)){return 1;}
    }
    else{
        if(((white.pawn>>pos)&1)|((white.knight>>pos)&1)|((white.bishop>>pos)&1)|((white.rook>>pos)&1)|((white.queen>>pos)&1)|((white.king>>pos)&1)){return 1;}
    }
}
void legal_move_generator(board friendly,board enemy,uint64_t *table){//friendly!=white
    table=(int*)malloc(2000*sizeof(int));//form of (original coordinate, next coordinate), 0~5th bit to board, 6th bit to promote to bishop, 7th bit to knight, 8th bit to rook, 9th bit to queen
    int length;
    int pos;
    int x;
    int y;
    for(int i=0;i<popcnt(friendly.pawn);i++){//pawn
        pos=location(current_board.pawn,i);
        x=pos%8;
        y=pos/8;
        if((!check_square(friendly,pos+8))&(!check_square(enemy,pos+8))){
            if(y==7){
                for(int j=6;j<10;j++){//promotion
                    table[length]=pos;
                    table[length+1]=(pos+8)&(1<<j);
                    length+=2;
                }
            }
            else{//move 1sq forward
                table[length]=pos;
                table[length+1]=pos+8;
                length+=2;
            }
            if(y==1){//move 2sq forward when y==1
                if((!check_square(friendly,pos+16))&(!check_square(enemy,pos+16))){
                    table[length]=pos;
                    table[length+1]=pos+16;
                    length+=2;
                }
            }
        }
    }
}
int main(){
    return 0;
}
